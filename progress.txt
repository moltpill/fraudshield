# Progress Log

Started: Thu Feb 19 21:32:30 SAST 2026

## Phase 1: Foundation


## STORY-001: Initialize monorepo with pnpm workspaces ‚úÖ
- Created pnpm-workspace.yaml
- Created root package.json with workspace scripts
- Created tsconfig.json with @fraudshield/* path aliases
- Created package.json for all 5 packages (shared, sdk, api, dashboard, admin)
- Added .gitignore
- All 8 tests passing
- Committed: f02724d

### STORY-001: Initialize monorepo with pnpm workspaces ‚úÖ
- pnpm workspaces auto-create symlinks in packages/*/node_modules ‚Äî added to .gitignore


### STORY-002: Setup shared types package ‚úÖ
- Created Tier enum (FREE, STARTER, GROWTH, SCALE, ENTERPRISE)
- Created Account type with id, email, name, tier, status, createdAt
- Created ApiKey type with id, accountId, key, name, status, allowedDomains, createdAt
- Created Visitor type with id, fingerprint, firstSeen, lastSeen, visits
- Created VisitorEvent type with id, visitorId, apiKeyId, signals, risk, timestamp
- Created UsageRecord type with id, accountId, date, count
- All types exported from index.ts
- 6 tests passing
- Committed: 1f742a0

**Learning:** Root tsconfig has `noEmit: true` for type-checking only; packages needing build output must override with `noEmit: false`

### STORY-002: Setup shared types package ‚úÖ
- Created Account, ApiKey, Visitor, VisitorEvent, UsageRecord, Tier types
- Root tsconfig has noEmit: true; packages needing build must override with noEmit: false


### STORY-003: Setup Prisma schema for accounts and API keys ‚úÖ
- Created prisma/schema.prisma with Account and ApiKey models
- SQLite datasource for development (DATABASE_URL env var)
- Account fields: id, email (unique), name, tier, status, createdAt
- ApiKey fields: id, accountId, key (unique), name, status, allowedDomains (JSON string), createdAt
- Relation: Account has many ApiKeys with cascade delete
- Added db:generate, db:push, db:studio scripts to package.json
- 6 tests passing (create, relations, unique constraints, tier values)
- Committed: f01c5c9

**Learning:** SQLite doesn't support enums ‚Äî use String fields with application-level validation instead. Prisma 7 has breaking changes (config file required); Prisma 5 is more stable for quick setup.

### STORY-003: Setup Prisma schema for accounts and API keys ‚úÖ
- SQLite doesn't support enums ‚Äî use String fields with app-level validation
- Prisma 5 is stable; Prisma 7 has breaking changes
- allowedDomains stored as JSON string (parse at app level)



### STORY-004: Setup Prisma schema for visitors and events ‚úÖ
- Created Visitor model with fingerprint (unique), firstSeen, lastSeen, visitCount
- Created VisitorEvent model with signals (JSON string), riskScore, detection flags (isBot, isVpn, isTor, isDatacenter)
- Index on Visitor.fingerprint for fast lookup
- Index on VisitorEvent.timestamp for time-based queries
- Index on VisitorEvent.visitorId and apiKeyId for relation lookups
- Relations: VisitorEvent ‚Üí Visitor (cascade delete), VisitorEvent ‚Üí ApiKey (cascade delete)
- Added visitorEvents relation to ApiKey model
- 8 tests covering creation, constraints, relations, and index usage
- Committed: 225fa17

**Learning:** Prisma needs to run from the package directory containing the schema, or use pnpm workspace scripts

### STORY-004: Setup Prisma schema for visitors and events ‚úÖ
- Visitor: fingerprint (unique+indexed), firstSeen, lastSeen, visitCount
- VisitorEvent: signals JSON, riskScore, detection flags (isBot, isVpn, isTor, isDatacenter)
- Prisma must run from package directory containing schema (not project root)



### STORY-005: Setup Prisma schema for usage tracking ‚úÖ
- Created UsageRecord model with accountId, date, requestCount
- Unique constraint on accountId + date (for atomic daily tracking)
- Created TierLimit model with tier (unique), monthlyLimit, features JSON
- Seed script populates all 5 tiers: FREE (1K), STARTER (10K), GROWTH (100K), SCALE (1M), ENTERPRISE (unlimited)
- Added usageRecords relation to Account model
- Fixed test isolation in all test files (beforeEach cleanup)
- 36 tests passing
- Committed: ecdcd1a

**Learning:** Test isolation is critical ‚Äî always add beforeEach cleanup when tests create related data. Adding new relations requires updating cleanup order in existing test files.

### STORY-005: Setup Prisma schema for usage tracking ‚úÖ
- UsageRecord: accountId + date unique constraint, requestCount with default 0
- TierLimit: tier (unique), monthlyLimit, features JSON
- Seed via `pnpm db:seed` or `prisma db seed`
- Test isolation requires cleaning child tables before parents

### STORY-005: Setup Prisma schema for usage tracking ‚úÖ
- UsageRecord: accountId + date unique constraint for daily tracking
- TierLimit: tier limits and features JSON, seeded for all 5 tiers
- Test isolation critical ‚Äî always add beforeEach cleanup when tests create related data


### STORY-006: Create API key generation utility ‚úÖ
- Created packages/shared/src/api-key.ts with generateApiKey(), validateApiKey(), getApiKeyType()
- Format: fs_live_ or fs_test_ prefix + 32 hex chars (16 random bytes)
- Uses Node's crypto.randomBytes for cryptographic security
- 10 tests covering generation, uniqueness, and validation
- Exported from @fraudshield/shared package index
- Fixed pre-existing test flakiness by adding vitest.config.ts with fileParallelism: false
- Committed: 7304c40

**Learning:** Vitest runs test files in parallel by default, which causes race conditions with shared database tests. Use `fileParallelism: false` in vitest.config.ts when tests share a database.

### STORY-006: Create API key generation utility ‚úÖ
- generateApiKey('live'|'test') ‚Üí fs_live_/fs_test_ + 32 hex chars
- validateApiKey() checks format, getApiKeyType() extracts type
- Vitest runs files in parallel by default ‚Üí use fileParallelism: false for shared DB tests


### STORY-007: Setup Vitest for monorepo ‚úÖ
- Configured vitest.config.ts with test.projects (modern approach, replaces deprecated vitest.workspace.ts)
- Each package has its own vitest.config.ts with package-specific settings
- Root-level tests (tests/workspace.test.ts) included via inline project config
- Coverage enabled with @vitest/coverage-v8 (v8 provider)
- pnpm test at root runs all 46 tests across all packages
- pnpm --filter @fraudshield/shared test runs only shared package tests (16)
- pnpm --filter @fraudshield/api test runs only api package tests (22)
- Test scripts added: test, test:watch, test:coverage

**Learning:** vitest.workspace.ts is deprecated in Vitest 3.x. Use test.projects array in vitest.config.ts instead. Inline project configs work for root-level tests.

### STORY-007: Setup Vitest for monorepo ‚úÖ
- vitest.workspace.ts deprecated in Vitest 3.x ‚Äî use test.projects in vitest.config.ts
- Coverage with @vitest/coverage-v8 provider
- 46 tests total, all passing

## PHASE 1 COMPLETE ‚úÖ


---
## Phase 2: SDK Core
Started: Thu Feb 19 22:03:19 SAST 2026


### STORY-008: Create SDK package structure ‚úÖ
- TypeScript configured with strict mode (tsconfig.json)
- Rollup config for UMD, ESM, and minified bundles (rollup.config.js)
- FraudShield class with constructor({ apiKey, endpoint? })
- Build produces sdk.min.js = 656 bytes (well under 10KB requirement)
- Package exports FraudShield class with types
- 8 tests covering constructor, options, and exports
- Total: 54 tests passing across all packages

**Learning:** Use private fields with underscore prefix (_apiKey) when they'll be used by future methods but aren't yet ‚Äî satisfies strict mode's noUnusedLocals without disabling the check.

### STORY-008: Create SDK package structure ‚úÖ
- Rollup config for UMD, ESM, and minified bundles
- FraudShield class with constructor({ apiKey, endpoint? })
- Build output: 656 bytes (well under 10KB target)
- Use underscore prefix for private fields to satisfy noUnusedLocals



### STORY-009: Implement canvas fingerprint signal ‚úÖ
- getCanvasFingerprint() in packages/sdk/src/signals/canvas.ts
- Draws text with emoji (üõ°Ô∏è üé®), colored text, and arc shapes
- Uses djb2 hash on canvas.toDataURL() for consistent fingerprint
- Returns 'canvas-not-supported' gracefully when canvas unavailable
- 7 tests covering all acceptance criteria
- Bundle size: 1.38KB (well under 10KB target)
- Total: 61 tests passing

**Learning:** Use djb2 hash for simple client-side hashing ‚Äî fast, deterministic, no dependencies. Canvas fingerprinting works by exploiting rendering differences across browsers/systems.

### STORY-009: Implement canvas fingerprint signal ‚úÖ
- Draws text with emoji, colored text, and arc shapes
- djb2 hash on canvas.toDataURL() ‚Äî fast, deterministic, no deps
- Returns 'canvas-not-supported' when unavailable
- Bundle: 1.38KB



### STORY-010: Implement WebGL fingerprint signal ‚úÖ
- getWebGLFingerprint() returns { renderer, vendor, hash }
- Uses WEBGL_debug_renderer_info extension (constants 0x9245, 0x9246)
- Falls back to 'unknown' if debug extension unavailable
- Falls back to 'webgl-not-supported' if no WebGL context
- Includes shader precision info (vertex/fragment HIGH_FLOAT) in hash
- djb2 hash function for consistency
- 8 tests covering all acceptance criteria
- Bundle: 1.38KB (unchanged from STORY-009)
- Total: 69 tests passing

**Learning:** WebGL debug extension constants (UNMASKED_VENDOR_WEBGL, UNMASKED_RENDERER_WEBGL) are 0x9245 and 0x9246 respectively ‚Äî use them directly if debugInfo object doesn't expose them.

### STORY-010: Implement WebGL fingerprint signal ‚úÖ
- Returns { renderer, vendor, hash }
- Uses WEBGL_debug_renderer_info extension (constants 0x9245, 0x9246)
- Shader precision included in hash
- Graceful fallback for missing WebGL/debug extension



### STORY-011: Implement audio fingerprint signal ‚úÖ
- getAudioFingerprint() in packages/sdk/src/signals/audio.ts
- Uses OfflineAudioContext with webkit fallback
- Creates oscillator (triangle wave, 10kHz) + DynamicsCompressor chain
- Renders 4500 samples at 44100Hz, extracts channel data
- djb2 hash on float32 samples (6 decimal precision)
- Returns 'audio-not-supported' when AudioContext unavailable
- 8 tests covering all acceptance criteria
- Bundle: 1.38KB (unchanged from STORY-010)
- Total: 77 tests passing

**Learning:** Audio fingerprinting uses OfflineAudioContext to render audio offline, then extracts the Float32Array channel data. Different browser audio stacks produce slightly different output for the same oscillator/compressor config.

### STORY-011: Implement audio fingerprint signal ‚úÖ
- OfflineAudioContext with oscillator (10kHz triangle) + DynamicsCompressor
- Extracts Float32Array channel data, hashes with djb2
- webkitOfflineAudioContext fallback for Safari
- Different browser audio stacks = different fingerprints


### STORY-012: Implement navigator signals collection ‚úÖ
- Collects userAgent, platform, language, languages, hardwareConcurrency, deviceMemory
- Includes cookieEnabled, doNotTrack, maxTouchPoints, plugins list



### STORY-013: Implement screen signals collection ‚úÖ
- getScreenSignals() returns ScreenSignals object with all metrics
- Includes: width, height, availWidth, availHeight, colorDepth, pixelDepth, devicePixelRatio, orientation
- Handles iframe restrictions with safeGetScreenProp() wrapper - catches thrown errors
- Orientation extracted separately - checks for both type and angle properties
- 8 tests covering all acceptance criteria including error handling
- Bundle: 1.38KB (unchanged)
- Total: 100 tests passing

**Learning:** Iframe sandboxing can throw DOMException on screen property access, not just return undefined. Use try/catch wrappers for robust signal collection in embedded contexts.

### STORY-013: Implement screen signals collection ‚úÖ
- Returns width, height, availWidth, availHeight, colorDepth, pixelDepth, devicePixelRatio, orientation
- safeGetScreenProp() wrapper catches DOMExceptions from iframe sandboxing
- Iframe sandboxing can throw DOMException on screen access (not just undefined)



### STORY-014: Implement timezone and locale signals ‚úÖ
- getTimezoneSignals() returns { timezone, timezoneOffset, locale }
- Uses Intl.DateTimeFormat().resolvedOptions().timeZone for IANA timezone name
- Uses Date().getTimezoneOffset() for minutes offset from UTC
- Returns navigator.language for locale
- Graceful fallbacks when APIs unavailable
- 8 tests covering all acceptance criteria
- Total: 108 tests passing

**Learning:** Intl.DateTimeFormat().resolvedOptions() provides the IANA timezone name (e.g., "America/New_York"), while Date.getTimezoneOffset() returns numeric minutes offset (positive = behind UTC). Combining both gives robust timezone detection for fraud signals.

### STORY-014: Implement timezone and locale signals ‚úÖ
- Returns { timezone, timezoneOffset, locale }
- Intl.DateTimeFormat().resolvedOptions() gives IANA timezone (e.g., 'America/New_York')
- Date.getTimezoneOffset() gives numeric minutes offset
- navigator.language for locale


### STORY-015: Implement WebRTC local IP detection ‚úÖ
- getWebRTCIPs() returns array of unique local IP addresses
- Uses RTCPeerConnection with Google STUN server
- Creates data channel + offer to trigger ICE gathering
- Extracts IPs from ICE candidate strings via regex
- Filters for private IPs only (10.x, 172.16-31.x, 192.168.x, 127.x)
- 3-second timeout prevents hanging
- Handles WebRTC disabled/blocked gracefully
- Cleans up peer connection after detection
- 8 tests covering all acceptance criteria
- Total: 116 tests passing

**Learning:** WebRTC IP detection works by creating RTCPeerConnection with STUN, then parsing ICE candidates. Filter for private IPs (10.x, 172.16-31.x, 192.168.x) to detect VPN leaks - public IPs from STUN are not useful for local detection. Always close peer connection to avoid resource leaks.

### STORY-015: Implement WebRTC local IP detection ‚úÖ
- Uses RTCPeerConnection with STUN to trigger ICE candidate gathering
- ICE candidate format: "candidate:... <ip> <port> typ host"
- Private IP ranges: 10.x, 172.16-31.x, 192.168.x, 127.x
- 3s timeout prevents hanging when WebRTC is blocked

### STORY-015: Implement WebRTC local IP detection ‚úÖ
- RTCPeerConnection with STUN (stun.l.google.com:19302)
- Create data channel ‚Üí create offer ‚Üí parse ICE candidates
- Filter for private IPs only (10.x, 172.16-31.x, 192.168.x, 127.x)
- 3 second timeout, always close peer connection after


### STORY-016: Implement bot detection signals ‚úÖ
- getBotSignals() returns detection flags object with 5 boolean signals
- Checks navigator.webdriver (Selenium/Puppeteer detection)
- Checks window.phantom (PhantomJS)
- Checks window.__selenium_* artifacts (multiple variants)
- Checks chrome.runtime in non-Chrome browsers (inconsistent environment)
- Checks for fake permissions API (sync vs async query detection)
- 18 tests covering all acceptance criteria
- Total: 134 tests passing

**Learning:** Bot detection relies on artifacts left by automation tools. navigator.webdriver is set by WebDriver spec, window.phantom by PhantomJS, and various __selenium_* / __webdriver_* globals by Selenium. Chrome.runtime in non-Chrome browsers indicates environment spoofing. Fake permissions APIs often return synchronous results instead of Promises - real browsers always return Promises from permissions.query().

### STORY-016: Implement bot detection signals ‚úÖ
- webdriver: navigator.webdriver (Selenium/Puppeteer)
- phantom: window.phantom (PhantomJS)
- selenium: __selenium_*/__webdriver_* artifacts (12+ checks)
- chromeRuntime: chrome.runtime in non-Chrome
- inconsistentPermissions: fake sync permissions API (real returns Promise)



### STORY-017: Create SDK analyze() method ‚úÖ
- analyze() collects all 8 signal types in parallel (canvas, webgl, audio, navigator, screen, timezone, webrtcIPs, bot)
- POSTs to configured endpoint + /v1/analyze
- Includes Authorization: Bearer <apiKey> header
- Returns parsed JSON response (visitorId, riskScore, flags, etc.)
- FraudShieldError class with optional statusCode and code properties
- Handles network errors, HTTP errors, and JSON parse failures gracefully
- 14 tests covering all acceptance criteria
- Total: 148 tests passing

**Learning:** Use Promise.all() for async signal collectors (canvas, webgl, audio, navigator, webrtcIPs) to collect in parallel for performance. Sync collectors (screen, timezone, bot) run immediately after. FraudShieldError needs Object.setPrototypeOf(this, FraudShieldError.prototype) for correct instanceof checks in transpiled code.

### STORY-017: Create SDK analyze() method ‚úÖ
- Collects all 8 signal types in parallel (Promise.all for async signals)
- POSTs to endpoint/v1/analyze with Authorization: Bearer header
- FraudShieldError with statusCode and code properties
- Object.setPrototypeOf needed for correct instanceof in transpiled code



### STORY-018: Add SDK error handling and types ‚úÖ
- ErrorCode constants: INVALID_KEY, QUOTA_EXCEEDED, NETWORK_ERROR, SUSPENDED
- AnalyzeResult type with visitorId, confidence, risk, signals properties
- FraudShieldOptions type already exported
- JSDoc comments on public methods (already present)
- Network errors now include NETWORK_ERROR code
- 15 tests covering error codes, types, and network error behavior
- Total: 163 tests passing

**Learning:** Use `as const` for error code objects to get proper literal types. ErrorCodeType derived as `(typeof ErrorCode)[keyof typeof ErrorCode]` gives union of literal values. Keep backward compatibility by adding new types alongside existing ones (AnalyzeResult added, AnalyzeResponse kept for existing tests).

### STORY-018: Add SDK error handling and types ‚úÖ
- ErrorCode: { INVALID_KEY, QUOTA_EXCEEDED, NETWORK_ERROR, SUSPENDED }
- AnalyzeResult: { visitorId, confidence, risk, signals, requestId? }
- Network errors include code: ErrorCode.NETWORK_ERROR

### STORY-018: Add SDK error handling and types ‚úÖ
- ErrorCode constants: INVALID_KEY, QUOTA_EXCEEDED, NETWORK_ERROR, SUSPENDED
- AnalyzeResult type with visitorId, confidence, risk, signals
- Use 'as const' for literal types, derive union with (typeof X)[keyof typeof X]


### STORY-019: Setup SDK build and minification ‚úÖ
- Rollup config with terser for minification and mangling
- Disabled source maps in dist (sourcemap: false) - not shipped to customers
- Output: sdk.min.js (UMD minified), sdk.esm.js (ESM), sdk.umd.js (UMD)
- Build size: ~3.2KB gzipped (well under 8KB target)
- UMD exposes FraudShield global for script tag usage
- 12 build tests covering all acceptance criteria
- Total: 175 tests passing

**Learning:** Set `sourcemap: false` in rollup output config to prevent .map files in dist. Terser `mangle: true` (default) handles variable name mangling. Don't ship source maps to production - they expose source code structure.

### STORY-019: Setup SDK build and minification ‚úÖ
- dist/sdk.min.js minified and mangled
- Source maps NOT included in dist (security)
- Build size: 3.2KB gzipped (well under 8KB target)
- UMD bundle exposes FraudShield global

## PHASE 2 COMPLETE ‚úÖ


---
## Phase 3: API Layer
Started: Thu Feb 19 22:35:47 SAST 2026


### STORY-020: Setup Hono API with basic structure ‚úÖ
- Hono app exported from app.ts (separates from server startup)
- index.ts uses @hono/node-server for Node.js runtime
- CORS middleware with origin: '*' for dev
- Request logging middleware logs: method, path, status, duration
- notFound() handler returns { error, code: 'NOT_FOUND' }
- onError() handler returns { error, code: 'INTERNAL_ERROR' }
- 9 new tests, total: 184 tests passing

**Learning:** Separate app definition (app.ts) from server startup (index.ts) for testability. Hono's app.request() method enables easy testing without starting actual server. Use notFound() for 404s, onError() for exceptions.


### STORY-020: Setup Hono API with basic structure ‚úÖ
- /health endpoint returns { status: 'ok', timestamp }
- CORS for all origins (dev), JSON error handling, request logging
- Separate app from server for testability ‚Äî use app.request() in tests
- notFound() for 404s, onError() for exceptions


### STORY-021: Implement API key validation middleware ‚úÖ
- Middleware extracts Bearer token from Authorization header
- Validates fs_live_ or fs_test_ prefix + 32 hex chars pattern
- Database lookup via Prisma with account included
- 401 for invalid/missing/revoked keys, 403 for suspended accounts
- Attaches apiKey and account to Hono context via c.set()
- Uses Prisma singleton pattern for dev hot reload
- 12 tests covering all acceptance criteria
- Total: 196 tests passing

**Learning:** Use `vi.hoisted()` in Vitest to define mock variables that are referenced inside `vi.mock()` factory functions - the factory is hoisted to top of file, so regular `const` declarations won't be defined yet. Also ensure test API keys match the exact format (32 hex chars) expected by validation regex.

### STORY-021: Implement API key validation middleware ‚úÖ
- Extracts key from Authorization: Bearer fs_* header
- Validates format, looks up in DB with account relation
- 401 for invalid/revoked keys, 403 for suspended accounts
- Attaches apiKey and account to Hono context
- Use vi.hoisted() when mocks reference variables in factory functions



### STORY-022: Implement usage tracking middleware ‚úÖ
- Middleware increments UsageRecord for account on each request
- Uses Prisma upsert for atomic create-or-increment (prevents race conditions)
- Aggregates all daily UsageRecord entries for current month using prisma.aggregate()
- Returns 429 RATE_LIMIT_EXCEEDED if monthly limit exceeded
- Includes X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset headers
- Reset timestamp is Unix epoch seconds of next month start
- Looks up tier limit from TierLimit table, falls back to 1000 if not found
- 12 tests covering happy path, rate limiting, headers, and aggregation
- Total: 208 tests passing

**Learning:** Use Prisma's aggregate() with _sum to sum values across multiple records (not findFirst). For atomicity, use upsert with `increment: 1` in update clause - this prevents race conditions when multiple requests arrive simultaneously.

### STORY-022: Implement usage tracking middleware ‚úÖ
- Atomic upsert with increment: 1 for daily UsageRecord
- Aggregates monthly usage with Prisma aggregate() + _sum
- 429 with RATE_LIMIT_EXCEEDED when over limit
- X-RateLimit-Limit/Remaining/Reset headers on all responses
- Use upsert with increment for atomic counters (no race conditions)



### STORY-023: Create fingerprint hashing service ‚úÖ
- computeFingerprint(signals) returns stable SHA-256 hash
- Normalizes signal JSON by sorting object keys recursively
- Excludes volatile keys: timestamp, requestTime, requestId, sessionId
- Arrays are NOT sorted (order matters for IP lists)
- Uses Node.js crypto.createHash for SHA-256
- 14 tests covering stability, normalization, and volatile exclusion
- Total: 222 tests passing

**Learning:** When normalizing objects for hashing, sort object keys recursively but preserve array order - arrays often have semantic meaning (e.g., IP discovery order). Use a VOLATILE_KEYS constant list to centralize which fields to exclude.

### STORY-023: Create fingerprint hashing service ‚úÖ
- computeFingerprint(signals) returns stable SHA-256 hash (64-char hex)
- Normalizes by recursively sorting object keys
- Preserves array order (semantic meaning for IP lists, etc.)
- Excludes volatile keys: timestamp, requestTime, requestId, sessionId



### STORY-024: Implement POST /v1/analyze endpoint ‚úÖ
- POST /v1/analyze accepts JSON body with signals object
- Computes fingerprint hash using computeFingerprint service
- Uses Prisma upsert to create or update Visitor record (atomic)
- Creates VisitorEvent with serialized signals JSON
- Returns visitorId, confidence, firstSeen, lastSeen
- Confidence calculated with logarithmic scaling: new visitors start at 0.5, returning visitors increase up to 0.99
- 9 tests covering: request validation, fingerprint computation, visitor upsert, event creation, confidence calculation
- Total: 231 tests passing

**Learning:** For visitor tracking, use Prisma upsert with increment on visitCount - this atomically handles both new and returning visitors. Confidence scoring should use logarithmic scaling to reflect diminishing certainty gains after many visits.

### STORY-024: Implement POST /v1/analyze endpoint ‚úÖ
- Accepts { signals } body, computes SHA-256 fingerprint
- Upserts Visitor (create or increment visitCount)
- Creates VisitorEvent with serialized signals
- Returns { visitorId, confidence, firstSeen, lastSeen }
- Confidence: 0.5 new, logarithmic increase up to 0.99 for returning



### STORY-025: Implement GET /v1/visitors/:id endpoint ‚úÖ
- GET /v1/visitors/:id returns visitor details (id, visitCount, firstSeen, lastSeen)
- Returns 404 with VISITOR_NOT_FOUND code if not found
- Scoped to account via Prisma relation filter: events.some.apiKey.accountId
- ?include=events returns up to 50 recent events (ordered by timestamp desc)
- Events filtered to account-owned API keys only
- 7 tests covering: found/not found, scoping, events include/exclude
- Total: 238 tests passing

**Learning:** To scope resources across relations in Prisma, use findFirst with nested relation filters (e.g., events.some.apiKey.accountId). This is more efficient than fetching all and filtering in code.

### STORY-025: Implement GET /v1/visitors/:id endpoint ‚úÖ
- Returns visitor details (id, visitCount, firstSeen, lastSeen)
- 404 with VISITOR_NOT_FOUND if not found
- Scoped to API key's account via events.some.apiKey.accountId filter
- ?include=events returns up to 50 recent events
- Use findFirst with nested relation filters for efficient scoping


### STORY-026: Implement GET /v1/visitors endpoint ‚úÖ
- GET /v1/visitors lists visitors with pagination (limit/offset, capped at 100)
- Filter by date range (?from=ISO&to=ISO) on lastSeen field
- Filter by risk level (?risk=high|medium|low) via events relation
- Risk thresholds: high ‚â•70, medium 30-69, low <30
- Returns total count for pagination info
- Ordered by lastSeen desc by default
- Scoped to account via events.some.apiKey.accountId filter
- 10 new tests covering: pagination, ordering, scoping, filters, count
- Total: 248 tests passing

**Learning:** For list endpoints with risk filtering, merge the risk filter into the existing events.some relation filter to avoid duplicate relation clauses. Use Promise.all for parallel findMany + count queries.

### STORY-026: Implement GET /v1/visitors endpoint ‚úÖ
- Pagination: limit (default 20, max 100) + offset
- Date filtering: ?from=ISO&to=ISO on lastSeen
- Risk filtering: ?risk=high|medium|low (‚â•70, 30-69, <30)
- Returns total count, ordered by lastSeen desc
- Use Promise.all for parallel findMany + count queries


### STORY-027: Implement GET /v1/usage endpoint ‚úÖ
- GET /v1/usage returns usage statistics for authenticated account
- Returns: currentMonthUsage, tierLimit, tier, percentageUsed, dailyBreakdown
- Fetches TierLimit by account.tier for monthly limit
- Queries UsageRecord for current month (date >= startOfMonth, < startOfNextMonth)
- Daily breakdown: array of { date: YYYY-MM-DD, count } ordered by date asc
- Percentage allows >100% to show overage clearly
- Handles missing tier limit gracefully (defaults to 0)
- 8 tests covering: usage count, tier limit, percentage, daily breakdown, edge cases
- Total: 256 tests passing

**Learning:** For month-bounded queries, use startOfMonth and startOfNextMonth with gte/lt (not lte) to avoid timezone edge cases. Use Promise.all for parallel independent queries.

### STORY-027: Implement GET /v1/usage endpoint ‚úÖ
- Returns currentMonthUsage, tierLimit, tier, percentageUsed
- dailyBreakdown array with { date, count } for each day
- For month bounds: gte startOfMonth, lt startOfNextMonth (avoids timezone issues)
- Promise.all for parallel tierLimit + usageRecords queries



### STORY-028: Add IP extraction and geolocation stub ‚úÖ
- extractClientIp() extracts client IP from X-Forwarded-For or X-Real-IP headers
- Falls back to socket IP if provided
- Handles IPv4, IPv6, and IPv4-mapped IPv6 addresses
- Takes first IP from comma-separated X-Forwarded-For list (client IP)
- GeoLocation interface defined with: country, countryCode, region, city, lat/lng, timezone, isp, asn
- getGeolocation() stub returns null (real implementation in future story)
- IP field added to VisitorEvent schema (nullable)
- Analyze route now extracts and stores client IP
- 19 new tests covering: header extraction, IPv4/IPv6, fallbacks, integration
- Total: 275 tests passing

**Learning:** For IP extraction from proxy headers, always take the first IP from X-Forwarded-For (comma-separated list) since proxies append their own IPs. Check X-Forwarded-For before X-Real-IP as it's more widely used.


### STORY-028: Add IP extraction and geolocation stub ‚úÖ
- extractClientIp(): X-Forwarded-For ‚Üí X-Real-IP ‚Üí socket fallback
- Handles IPv4 and IPv6
- GeoLocation interface defined, stub returns null (ready for GeoLite2)
- IP field added to VisitorEvent schema
- Analyze route now extracts and stores client IP

## PHASE 3 COMPLETE ‚úÖ


---
## Phase 4: Customer Dashboard
Started: Fri Feb 20 2026


### STORY-029: Setup Next.js dashboard with auth ‚úÖ
- Next.js 15 with App Router in packages/dashboard (runs on port 3002)
- next-auth v5 (Auth.js) configured with Credentials provider
- Auth validates against Account table using bcryptjs password comparison
- Added password field to Prisma Account model (nullable String)
- Login page at /login with shadcn/ui components (Card, Input, Label, Button)
- Middleware protects all routes except /login and /api/auth/*
- Authenticated users redirected away from /login to /dashboard
- Unauthenticated users redirected to /login with callbackUrl preserved
- Session (JWT strategy) includes: accountId, email, name, tier
- Dashboard package uses Prisma client referencing api's schema via package.json "prisma.schema"
- shadcn/ui components: Button, Input, Label, Card created manually
- 36 tests passing across 3 test files (auth, middleware, login page)

**Learning:** next-auth v5 (Auth.js) exports { handlers, auth, signIn, signOut } from a single auth.ts config file. Route handler at /api/auth/[...nextauth]/route.ts just re-exports handlers. Middleware uses the auth() wrapper function. In pnpm monorepo, point dashboard's Prisma to api's schema via "prisma": { "schema": "../api/prisma/schema.prisma" } in package.json.

